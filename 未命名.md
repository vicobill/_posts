 struct appdata {

 float4 vertex : POSITION;

  

 float4 prev : TEXCOORD0;

 float4 next : TEXCOORD1;

 float2 orient : TEXCOORD3;

 };

  

 struct v2f {

 float4 vertex : SV_POSITION;

 float2 uv : TEXCOORD0;

 };

  

 float4 _Color;

 float _Thickness;

 float _ThicknessMultiplier;

 float _MiterThreshold;

 float _Perspective;

 // Â sampler2D _MainTex;

 // float4 _MainTex_ST;

  

 v2f vert(appdata v) {

 v2f o;

 // o.uv = TRANSFORM_TEX(v.uv, _MainTex);

  

 float4 current = TransformObjectToHClip(v.vertex);

 float4 prev = TransformObjectToHClip(v.prev);

 float4 next = TransformObjectToHClip(v.next);

  

 float2 current_screen = current.xy / current.w * _ScreenParams.xy;

 float2 prev_screen = prev.xy / prev.w * _ScreenParams.xy;

 float2 next_screen = next.xy / next.w * _ScreenParams.xy;

  

 float len = _Thickness * _ThicknessMultiplier;

 float2 dir = float2(0,0);

  

 if (v.orient.y == 1.0) {

 dir = normalize(next_screen - current_screen);

 }

 else if (v.orient.y == 2.0) {

 dir = normalize(current_screen - prev_screen);

 }

 else {

 float2 dirA = normalize(current_screen - prev_screen);

 float2 dirB = normalize(next_screen - current_screen);

  

 float flip = sign(.1 + sign(dot(dirA,dirB) + _MiterThreshold));

  

 dirB *= flip;

  

 float2 tangent = (dirA + dirB) / 2; //Divide by two normalizes since len is 2.

 float2 perp_dirA = float2(-dirA.y, dirA.x);

 float2 perp_tangent = float2(-tangent.y, tangent.x);

  

 dir = tangent;

 len /= dot(perp_tangent, perp_dirA);

 }

  

 float2 normal = (float2(-dir.y, dir.x));

 // One might think that we should "extrude" only half of the length,

 // since the other point will also be moved away from this point by the same distance.

 // However, we are actually only moving half of len pixels since the space we are working in

 // is twice as large as the screen: (-width, +width) rather than (0, width) and same for the height.

 // Essentially there are two factor of two which cancel each other out.

 normal *= len;

 normal *= _ScreenParams.zw - 1; // Equivalent to `normal /= _ScreenParams.xy` but with less division.

  

 float2 offset = normal * v.orient.x;

 o.vertex = current + float4(offset * pow(current.w, 1 - _Perspective), 1, 0);

  

 return o;

 }

  

 float4 frag(v2f i) : SV_Target

 {

 // float4 col = tex2D(_MainTex, i.uv);

 return _Color + abs(_Color * _SinTime.w);

 }